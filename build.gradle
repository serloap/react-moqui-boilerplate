plugins {
    id 'groovy'
    id "com.moowork.node" version "1.3.1"
}

sourceCompatibility = '1.8'
def componentNode = parseComponent(project)
version = componentNode.'@version'
def jarBaseName = componentNode.'@name'
def moquiDir = projectDir.parentFile.parentFile.parentFile
def frameworkDir = file(moquiDir.absolutePath + '/framework')
def frontendDir = projectDir.absolutePath + '/frontend'

repositories {
    flatDir name: 'localLib', dirs: frameworkDir.absolutePath + '/lib'
    jcenter()
}

tasks.withType(JavaCompile) { options.compilerArgs << "-proc:none" }
tasks.withType(GroovyCompile) { options.compilerArgs << "-proc:none" }

dependencies {
    compile project(':framework')
    compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.0'
    // compile 'org.jcodec:jcodec:0.2.5'
    // compile 'org.jcodec:jcodec-javase:0.2.5'
    // compile group: 'org.apache.pdfbox', name: 'pdfbox', version: '2.0.1'
    // compile module('net.sf.barcode4j:barcode4j:2.1')
    testCompile project(':framework').configurations.testCompile.allDependencies
}

check.dependsOn.clear()

node {
    download = true
}

task appNpmInstall(type: NpmTask) {
    description = "Installs dependencies from package.json"
    def srcDir = [frontendDir + "/package.json"]
    inputs.files(srcDir)
    def nodeModulesDir = frontendDir + "/node_modules"
    outputs.dir nodeModulesDir
    workingDir = file(frontendDir)
    args = ['install']
}

task npmRunBuild(type: NpmTask) {
    description = "Building React Moqui Component"
    dependsOn appNpmInstall

    def srcDir = [fileTree(frontendDir + "/src"), fileTree(frontendDir + "/node_modules").exclude(".cache")]
    inputs.files(srcDir)
    def distDir = frontendDir + "/build"
    outputs.dir distDir
    workingDir = file(frontendDir)
    args = ['run', 'build']
}

build {
    // dependsOn npmRunBuild
    // doLast {
    //     copy {
    //         from frontendDir + '/build'
    //         into './screen/reactMoquiComponent'
    //         include '**'
    //     }
    // }
}

task cleanLib(type: Delete) {
    delete fileTree(dir: projectDir.absolutePath+'/lib', include: '*')
}

task cleanAll(type: Delete) {
    delete file(frontendDir + '/node_modules')
    delete file(frontendDir + '/build')
    delete file(projectDir.absolutePath+'/screen/reactMoquiComponent')
}

clean.dependsOn cleanLib
clean.dependsOn cleanAll

jar {
    destinationDir = file(projectDir.absolutePath + '/lib')
    baseName = jarBaseName
}
task copyDependencies { doLast {
    copy { from (configurations.runtime - project(':framework').configurations.runtime - project(':framework').jar.archivePath)
        into file(projectDir.absolutePath + '/lib') }
} }

test {
    dependsOn cleanTest
    systemProperty 'moqui.runtime', moquiDir.absolutePath + '/runtime'
    systemProperty 'moqui.conf', 'conf/MoquiDevConf.xml'
    systemProperty 'moqui.init.static', 'true'
    maxHeapSize = "512M"

    // show standard out and standard error of the test JVM(s) on the console
    testLogging.showStandardStreams = true; testLogging.showExceptions = true

    classpath += files(sourceSets.main.output.classesDirs)
    // filter out classpath entries that don't exist (gradle adds a bunch of these), or ElasticSearch JarHell will blow up
    classpath = classpath.filter { it.exists() }

    beforeTest { descriptor -> logger.lifecycle("Running test: ${ descriptor }") }
}

copyDependencies.dependsOn cleanLib
jar.dependsOn copyDependencies
